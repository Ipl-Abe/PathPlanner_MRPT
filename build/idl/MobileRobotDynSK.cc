// This file is generated by omniidl (C++ backend) - omniORB_4_2. Do not edit.

#include "MobileRobot.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_2_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_RTC_mTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"nsec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTime
#  undef _0RL_tc_RTC_mTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Time:1.0", "Time", _0RL_structmember_RTC_mTime, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mPoint2D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPoint2D
#  undef _0RL_tc_RTC_mPoint2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoint2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Point2D:1.0", "Point2D", _0RL_structmember_RTC_mPoint2D, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mPose2D[] = {
  {"position", _0RL_tc_RTC_mPoint2D},
  {"heading", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPose2D
#  undef _0RL_tc_RTC_mPose2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPose2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Pose2D:1.0", "Pose2D", _0RL_structmember_RTC_mPose2D, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mOGMapConfig[] = {
  {"xScale", CORBA::TypeCode::PR_double_tc()},
  {"yScale", CORBA::TypeCode::PR_double_tc()},
  {"width", CORBA::TypeCode::PR_ulong_tc()},
  {"height", CORBA::TypeCode::PR_ulong_tc()},
  {"origin", _0RL_tc_RTC_mPose2D}
};

#ifdef _0RL_tc_RTC_mOGMapConfig
#  undef _0RL_tc_RTC_mOGMapConfig
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOGMapConfig = CORBA::TypeCode::PR_struct_tc("IDL:RTC/OGMapConfig:1.0", "OGMapConfig", _0RL_structmember_RTC_mOGMapConfig, 5, &_0RL_tcTrack);

static CORBA::TypeCode_ptr _0RL_tc_RTC_mOGMapCells = CORBA::TypeCode::PR_alias_tc("IDL:RTC/OGMapCells:1.0", "OGMapCells", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_RTC_mOGMapTile[] = {
  {"column", CORBA::TypeCode::PR_ulong_tc()},
  {"row", CORBA::TypeCode::PR_ulong_tc()},
  {"width", CORBA::TypeCode::PR_ulong_tc()},
  {"height", CORBA::TypeCode::PR_ulong_tc()},
  {"cells", _0RL_tc_RTC_mOGMapCells}
};

#ifdef _0RL_tc_RTC_mOGMapTile
#  undef _0RL_tc_RTC_mOGMapTile
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOGMapTile = CORBA::TypeCode::PR_struct_tc("IDL:RTC/OGMapTile:1.0", "OGMapTile", _0RL_structmember_RTC_mOGMapTile, 5, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mOGMap[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"config", _0RL_tc_RTC_mOGMapConfig},
  {"map", _0RL_tc_RTC_mOGMapTile}
};

#ifdef _0RL_tc_RTC_mOGMap
#  undef _0RL_tc_RTC_mOGMap
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOGMap = CORBA::TypeCode::PR_struct_tc("IDL:RTC/OGMap:1.0", "OGMap", _0RL_structmember_RTC_mOGMap, 3, &_0RL_tcTrack);






#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_OGMap = _0RL_tc_RTC_mOGMap;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_OGMap = _0RL_tc_RTC_mOGMap;
#endif


static const char* _0RL_enumMember_RTC_mRETURN__VALUE[] = { "RETVAL_OK", "RETVAL_INVALID_PARAMETER", "RETVAL_EMPTY_MAP", "RETVAL_INVALID_PRECONDITION", "RETVAL_NOT_IMPL", "RETVAL_UNKNOWN_ERROR", "RETVAL_NOT_FOUND", "RETVAL_ODOMETRY_INVALID_VALUE", "RETVAL_ODOMETRY_TIME_OUT", "RETVAL_RANGE_INVALID_VALUE", "RETVAL_RANGE_TIME_OUT", "RETVAL_EMERGENCY_STOP", "RETVAL_OUTOF_RANGE" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRETURN__VALUE = CORBA::TypeCode::PR_enum_tc("IDL:RTC/RETURN_VALUE:1.0", "RETURN_VALUE", _0RL_enumMember_RTC_mRETURN__VALUE, 13, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RETURN_VALUE = _0RL_tc_RTC_mRETURN__VALUE;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RETURN_VALUE = _0RL_tc_RTC_mRETURN__VALUE;
#endif

static const char* _0RL_enumMember_RTC_mMAPPER__STATE[] = { "MAPPER_STOPPED", "MAPPER_MAPPING", "MAPPER_SUSPEND", "MAPPER_ERROR", "MAPPER_UNKNOWN" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mMAPPER__STATE = CORBA::TypeCode::PR_enum_tc("IDL:RTC/MAPPER_STATE:1.0", "MAPPER_STATE", _0RL_enumMember_RTC_mMAPPER__STATE, 5, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_MAPPER_STATE = _0RL_tc_RTC_mMAPPER__STATE;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_MAPPER_STATE = _0RL_tc_RTC_mMAPPER__STATE;
#endif

static const char* _0RL_enumMember_RTC_mFOLLOWER__STATE[] = { "FOLLOWER_STOPPED", "FOLLOWER_FOLLOWING", "FOLLOWER_SUSPEND", "FOLLOWER_ERROR", "FOLLOWER_UNKNOWN" };
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFOLLOWER__STATE = CORBA::TypeCode::PR_enum_tc("IDL:RTC/FOLLOWER_STATE:1.0", "FOLLOWER_STATE", _0RL_enumMember_RTC_mFOLLOWER__STATE, 5, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FOLLOWER_STATE = _0RL_tc_RTC_mFOLLOWER__STATE;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FOLLOWER_STATE = _0RL_tc_RTC_mFOLLOWER__STATE;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_OGMapper = CORBA::TypeCode::PR_interface_tc("IDL:RTC/OGMapper:1.0", "OGMapper", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_OGMapper = CORBA::TypeCode::PR_interface_tc("IDL:RTC/OGMapper:1.0", "OGMapper", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_OGMapServer = CORBA::TypeCode::PR_interface_tc("IDL:RTC/OGMapServer:1.0", "OGMapServer", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_OGMapServer = CORBA::TypeCode::PR_interface_tc("IDL:RTC/OGMapServer:1.0", "OGMapServer", &_0RL_tcTrack);
#endif












static CORBA::PR_structMember _0RL_structmember_RTC_mVelocity2D[] = {
  {"vx", CORBA::TypeCode::PR_double_tc()},
  {"vy", CORBA::TypeCode::PR_double_tc()},
  {"va", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVelocity2D
#  undef _0RL_tc_RTC_mVelocity2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVelocity2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Velocity2D:1.0", "Velocity2D", _0RL_structmember_RTC_mVelocity2D, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mPathPlanParameter[] = {
  {"map", _0RL_tc_RTC_mOGMap},
  {"targetPose", _0RL_tc_RTC_mPose2D},
  {"currentPose", _0RL_tc_RTC_mPose2D},
  {"distanceTolerance", CORBA::TypeCode::PR_double_tc()},
  {"headingTolerance", CORBA::TypeCode::PR_double_tc()},
  {"timeLimit", _0RL_tc_RTC_mTime},
  {"maxSpeed", _0RL_tc_RTC_mVelocity2D}
};

#ifdef _0RL_tc_RTC_mPathPlanParameter
#  undef _0RL_tc_RTC_mPathPlanParameter
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPathPlanParameter = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PathPlanParameter:1.0", "PathPlanParameter", _0RL_structmember_RTC_mPathPlanParameter, 7, &_0RL_tcTrack);













#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PathPlanParameter = _0RL_tc_RTC_mPathPlanParameter;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PathPlanParameter = _0RL_tc_RTC_mPathPlanParameter;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PathPlanner = CORBA::TypeCode::PR_interface_tc("IDL:RTC/PathPlanner:1.0", "PathPlanner", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PathPlanner = CORBA::TypeCode::PR_interface_tc("IDL:RTC/PathPlanner:1.0", "PathPlanner", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PathFollower = CORBA::TypeCode::PR_interface_tc("IDL:RTC/PathFollower:1.0", "PathFollower", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PathFollower = CORBA::TypeCode::PR_interface_tc("IDL:RTC/PathFollower:1.0", "PathFollower", &_0RL_tcTrack);
#endif

static void _0RL_RTC_mOGMap_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::OGMap* _p = (RTC::OGMap*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mOGMap_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::OGMap* _p = new RTC::OGMap;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mOGMap_destructor_fn(void* _v)
{
  RTC::OGMap* _p = (RTC::OGMap*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::OGMap& _s)
{
  RTC::OGMap* _p = new RTC::OGMap(_s);
  _a.PR_insert(_0RL_tc_RTC_mOGMap,
               _0RL_RTC_mOGMap_marshal_fn,
               _0RL_RTC_mOGMap_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::OGMap* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mOGMap,
               _0RL_RTC_mOGMap_marshal_fn,
               _0RL_RTC_mOGMap_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMap*& _sp)
{
  return _a >>= (const RTC::OGMap*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OGMap*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mOGMap,
                    _0RL_RTC_mOGMap_unmarshal_fn,
                    _0RL_RTC_mOGMap_marshal_fn,
                    _0RL_RTC_mOGMap_destructor_fn,
                    _v)) {
    _sp = (const RTC::OGMap*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRETURN__VALUE_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RETURN_VALUE* _p = (RTC::RETURN_VALUE*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRETURN__VALUE_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RETURN_VALUE* _p = (RTC::RETURN_VALUE*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::RETURN_VALUE _s)
{
  _a.PR_insert(_0RL_tc_RTC_mRETURN__VALUE,
               _0RL_RTC_mRETURN__VALUE_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RETURN_VALUE& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mRETURN__VALUE,
                       _0RL_RTC_mRETURN__VALUE_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mMAPPER__STATE_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::MAPPER_STATE* _p = (RTC::MAPPER_STATE*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mMAPPER__STATE_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::MAPPER_STATE* _p = (RTC::MAPPER_STATE*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::MAPPER_STATE _s)
{
  _a.PR_insert(_0RL_tc_RTC_mMAPPER__STATE,
               _0RL_RTC_mMAPPER__STATE_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::MAPPER_STATE& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mMAPPER__STATE,
                       _0RL_RTC_mMAPPER__STATE_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mFOLLOWER__STATE_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FOLLOWER_STATE* _p = (RTC::FOLLOWER_STATE*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFOLLOWER__STATE_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FOLLOWER_STATE* _p = (RTC::FOLLOWER_STATE*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, RTC::FOLLOWER_STATE _s)
{
  _a.PR_insert(_0RL_tc_RTC_mFOLLOWER__STATE,
               _0RL_RTC_mFOLLOWER__STATE_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FOLLOWER_STATE& _s)
{
  return _a.PR_extract(_0RL_tc_RTC_mFOLLOWER__STATE,
                       _0RL_RTC_mFOLLOWER__STATE_unmarshal_fn,
                       &_s);
}

static void _0RL_RTC_mOGMapper_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mOGMapper_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::OGMapper::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mOGMapper_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::OGMapper_ptr _o)
{
  RTC::OGMapper_ptr _no = RTC::OGMapper::_duplicate(_o);
  _a.PR_insert(RTC::_tc_OGMapper,
               _0RL_RTC_mOGMapper_marshal_fn,
               _0RL_RTC_mOGMapper_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::OGMapper_ptr* _op)
{
  _a.PR_insert(RTC::_tc_OGMapper,
               _0RL_RTC_mOGMapper_marshal_fn,
               _0RL_RTC_mOGMapper_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::OGMapper::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapper_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_OGMapper,
                    _0RL_RTC_mOGMapper_unmarshal_fn,
                    _0RL_RTC_mOGMapper_marshal_fn,
                    _0RL_RTC_mOGMapper_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::OGMapper_ptr)_r->_ptrToObjRef(RTC::OGMapper::_PD_repoId);
    else
      _o = RTC::OGMapper::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mOGMapServer_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mOGMapServer_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::OGMapServer::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mOGMapServer_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::OGMapServer_ptr _o)
{
  RTC::OGMapServer_ptr _no = RTC::OGMapServer::_duplicate(_o);
  _a.PR_insert(RTC::_tc_OGMapServer,
               _0RL_RTC_mOGMapServer_marshal_fn,
               _0RL_RTC_mOGMapServer_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::OGMapServer_ptr* _op)
{
  _a.PR_insert(RTC::_tc_OGMapServer,
               _0RL_RTC_mOGMapServer_marshal_fn,
               _0RL_RTC_mOGMapServer_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::OGMapServer::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::OGMapServer_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_OGMapServer,
                    _0RL_RTC_mOGMapServer_unmarshal_fn,
                    _0RL_RTC_mOGMapServer_marshal_fn,
                    _0RL_RTC_mOGMapServer_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::OGMapServer_ptr)_r->_ptrToObjRef(RTC::OGMapServer::_PD_repoId);
    else
      _o = RTC::OGMapServer::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPathPlanParameter_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PathPlanParameter* _p = (RTC::PathPlanParameter*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPathPlanParameter_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PathPlanParameter* _p = new RTC::PathPlanParameter;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPathPlanParameter_destructor_fn(void* _v)
{
  RTC::PathPlanParameter* _p = (RTC::PathPlanParameter*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PathPlanParameter& _s)
{
  RTC::PathPlanParameter* _p = new RTC::PathPlanParameter(_s);
  _a.PR_insert(_0RL_tc_RTC_mPathPlanParameter,
               _0RL_RTC_mPathPlanParameter_marshal_fn,
               _0RL_RTC_mPathPlanParameter_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PathPlanParameter* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPathPlanParameter,
               _0RL_RTC_mPathPlanParameter_marshal_fn,
               _0RL_RTC_mPathPlanParameter_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PathPlanParameter*& _sp)
{
  return _a >>= (const RTC::PathPlanParameter*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PathPlanParameter*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPathPlanParameter,
                    _0RL_RTC_mPathPlanParameter_unmarshal_fn,
                    _0RL_RTC_mPathPlanParameter_marshal_fn,
                    _0RL_RTC_mPathPlanParameter_destructor_fn,
                    _v)) {
    _sp = (const RTC::PathPlanParameter*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPathPlanner_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mPathPlanner_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::PathPlanner::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mPathPlanner_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::PathPlanner_ptr _o)
{
  RTC::PathPlanner_ptr _no = RTC::PathPlanner::_duplicate(_o);
  _a.PR_insert(RTC::_tc_PathPlanner,
               _0RL_RTC_mPathPlanner_marshal_fn,
               _0RL_RTC_mPathPlanner_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::PathPlanner_ptr* _op)
{
  _a.PR_insert(RTC::_tc_PathPlanner,
               _0RL_RTC_mPathPlanner_marshal_fn,
               _0RL_RTC_mPathPlanner_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::PathPlanner::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PathPlanner_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_PathPlanner,
                    _0RL_RTC_mPathPlanner_unmarshal_fn,
                    _0RL_RTC_mPathPlanner_marshal_fn,
                    _0RL_RTC_mPathPlanner_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::PathPlanner_ptr)_r->_ptrToObjRef(RTC::PathPlanner::_PD_repoId);
    else
      _o = RTC::PathPlanner::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPathFollower_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RTC_mPathFollower_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RTC::PathFollower::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RTC_mPathFollower_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RTC::PathFollower_ptr _o)
{
  RTC::PathFollower_ptr _no = RTC::PathFollower::_duplicate(_o);
  _a.PR_insert(RTC::_tc_PathFollower,
               _0RL_RTC_mPathFollower_marshal_fn,
               _0RL_RTC_mPathFollower_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RTC::PathFollower_ptr* _op)
{
  _a.PR_insert(RTC::_tc_PathFollower,
               _0RL_RTC_mPathFollower_marshal_fn,
               _0RL_RTC_mPathFollower_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RTC::PathFollower::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PathFollower_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(RTC::_tc_PathFollower,
                    _0RL_RTC_mPathFollower_unmarshal_fn,
                    _0RL_RTC_mPathFollower_marshal_fn,
                    _0RL_RTC_mPathFollower_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RTC::PathFollower_ptr)_r->_ptrToObjRef(RTC::PathFollower::_PD_repoId);
    else
      _o = RTC::PathFollower::_nil();
    return 1;
  }
  return 0;
}

